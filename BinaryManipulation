#include <stdio.h>
#define true 1;
#define false 0;

typedef struct s_Register {
    int IdCliente;
    int IdFilme;
    char NomeCliente[50];
    char NomeFilme[50];
    char Genero[50];
} REGISTER;

typedef struct s_Key {
    int IdCliente;
    int IdFilme;
} KEY;

/*

    SORBE O ARQUIVO QUE TEREMOS COMO RESULTADO (DataResult.bin):
    header vai ter 3 informacoes: 
        - 1 int q vai ser o endereco de memoria da lista de removidos
        - 1 char para salvar que posicao do vetor de inserir paramos (aqui pode ser char pq n vai passar de 255)
        - 1 char para salvar que posicao do vetor de remocao paramos (aqui pode ser char pq n vai passar de 255)

    SOBRE O REGISTRO:
    primeiro campo: Tamanho do Registro
    segundo campo: Valido ($) ou Invalido (*)
    terceiro campo: Codigo do Cliente
    quarto campo: Codigo do Filme
    quinto campo: Nome do Cliente
    sexto campo: Nome do Filme
    setimo campo: Genero

    A partir do terceiro campo, eles vao ser separados usando # (obrigatorio) 

*/

void Insert(REGISTER registerData)
{
    /*
    abre DataResult.bin
    recebe o registro a ser inserido
    salva o tamanho dele - size (vamos usar para comparar daqui a pouco)
    verifica o Header 
        se ele for -1
            adiciona no final do arquivo DataResult.bin
            printa falando que o registro foi inserido com sucesso no final do arquivo
            return
        senao
            endereco = verifica(endereco que ta no header, size);
            (é uma funcao recursiva)
    adiciona no endereco
    printa falando que o registro foi inserido com sucesso a partir do byte "x"

    return
    */
}

int Verifica(int address, int size)
{
    /*
    verifica quanto espaço tem aquele endereco de memoria 
        se ele for -1 
            retorna -1
        se ele for maior q size 
            retorna esse endereco 
        senao
            result = verifica o proximo
    return result
    */
}

void Remove(KEY key)
{
    /*
    recebe a chave a ser removida “CodCli+CodF”
    abre DataResult.bin
    removido = false
    percorre todos os registros
        se a chave bate
            printa o registro a ser removido (acho bom q assim a gente sempre vai ter nocao das coisas)
            printa falando que a remocao foi feita com sucesso
            marca o segundo campo com * 
            marca o endereco que tinha no header
            muda o endereco do header para o endereco desse registro
            removido = true
    se removido = false
        printa falando que nao foi possivel localizar chave
    */

}

void Compress()
{

}

int main(int argc, char const *argv[])
{
    
    //le o arquivo insere.bin
        //verifica quantos inserts tem la dentro
        //salva isso em insertSize
        //aloca o vetor com insertSize 
        //preenche o vetor insertData[]
    //fecha insere.bin

    REGISTER* insertData;
    int exemple = 2;
    insertData = (REGISTER *) malloc(exemple * sizeof(REGISTER));

    
    //le o arquivo remove.bin
        //preenche o vetor removeData[]
    //fecha remove.bin

    KEY* removeData;


    //le o arquivo DataResult.bin
        //recebe as 2 infos do header sobre os vetores 
        //posicao_para_inserir = segundo campo do header
        //posicao_para_remover = terceiro campo do header

    int posicao_para_inserir = 0;
    int posicao_para_remover = 0;

    printf("--------- MENU ---------\n");
    printf(" (1) - Inserir Registro\n");
    printf(" (2) - Remover Registro\n");
    printf(" (3) - Compactar Arquivo\n");
    printf(" (4) - Sair\n");
    
    int option, repeat = true;
    while(repeat)
    {

        printf("Opcao: ");
        scanf("%d", &option);

        switch (option)
        {
        case 1:
            Insert(/*insertData[posicao_para_inserir]*/);
            posicao_para_inserir++;
            break;

        case 2:
            Remove(/*removeData[posicao_para_remover]*/);
            posicao_para_remover++;
            break;

        case 3:
            Compress();
            break;

        case 4:
            printf("Finalizando...\n\n\n");
            repeat = false;
            break;
        
        default:
            break;
        }
    }

    return 0;
}